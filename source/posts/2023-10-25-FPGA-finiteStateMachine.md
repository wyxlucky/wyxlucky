---
title: 状态机的三种写法
date: 2023/10/25
categories: FPGA
tags: [FPGA,状态机]
---

<!-- toc -->

<!-- more -->



[TOC]



# FPGA状态机编码的三种方式

## 一、读热码

独热码（One-hot）是一种状态编码方式，其特点是对于任意给定的状态，状态寄存器中只有1位为1，其余位都为0。使用独热码可以简化译码逻辑电路，因为状态机只需对寄存器中的一位进行译码。

- n个bits的读热码可以表示$n$种状态；
- **举例**：如若有4个状态，则需要4个比特来表示（S0=0001，S1=0010，S2=0100，S3=1000）
- <font color='red'>独热码适合写条件复杂但是状态少的状态机， 这种编码方式还易于修改，增加状态或改变状态转换条件都可以在不影响状态机的其它部分的情况下很方便地实现。</font>

## 二、格雷码

在一组数的编码中，若任意两个相邻的代码只有**一位bit发生变化**，则称这种编码为格雷码（Gray Code），另外由于最大数与最小数之间也仅一位数不同，即“首尾相连”，因此又称循环码或反射码。

- n个bits的格雷码可以表示$2^{n}$种状态；

- **举例**：如若有4个状态，则只需要2个比特来表示（S0=2‘b00, S1=2‘b01, S2=2‘b11, S3=2‘b01）；

- 格雷码适合写条件不复杂但是状态多的状态机。

- 由于格雷码是一种变权码，每一位码没有固定的大小，很难直接进行比较大小和算术运算，也不能直接转换成液位信号，要经过一次码变换，变成自然二进制码，再由上位机读取。

- 格雷码的十进制数奇偶性与其码字中1的个数的奇偶性相同。

## 三、二进制码

在一组数的编码中，若任意两个相邻的代码只有**一位bit不同**（**逐渐+1**），则称这种编码为二进制码，也可称连续编码，也就是码元值的大小是连续变化的。

**举例**：如若有4个状态，则只需要2个比特来表示（S0=2‘b00, S1=2‘b01, S2=2‘b11, S3=2‘b01）

# 格雷码与二进制码的区别

在上面提到的用2个bit来说明格雷码和二进制码的区别并不是很明显，接下来我们用3个bit来进行说明：

| 十进制数 | 二进制编码 | 格雷码编码 |
| :------: | :--------: | :--------: |
|    0     |    000     |    000     |
|    1     |    001     |    001     |
|    2     |    010     |    011     |
|    3     |    011     |    010     |
|    4     |    100     |    110     |
|    5     |    101     |    111     |
|    6     |    110     |    101     |
|    7     |    111     |    100     |

- **在标准二进制编码中，相邻码字之间可能会有多位二进制位同时改变，导致数字震荡的产生。而在格雷码编码中，相邻码字只有一位二进制位发生改变，从而降低了数字震荡的可能性。在模数转换中，使用格雷码编码可以减少不稳定性，提高信号的质量。**

# 三种编码方式的生成

待补充

# 格雷码与二进制码的转换

- 转载至:[FPGA状态机详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/618712669)

## 格雷码转二进制码

![grey2bin](.\2023-10-25-coding-finiteStateMachine\grey2bin.jpg)

```
module gray2bin#(
    parameter   DATA_WIDTH = 8
)(
    input   [DATA_WIDTH-1:0]  gray,
    output  [DATA_WIDTH-1:0]  bin
);

    genvar          i;

    assign bin[DATA_WIDTH-1] = gray[DATA_WIDTH-1];

    generate
        for(i = 0; i < DATA_WIDTH-1; i = i+1) begin : gray_to_bin
            assign bin[i] = gray[i]^bin[i+1];
        end
    endgenerate

endmodule
```

## 二进制码转格雷码

<img src=".\2023-10-25-coding-finiteStateMachine\bin2gery.jpg" alt="bin2gery" style="zoom:67%;" />

```
module bin2gray#(
    parameter   DATA_WIDTH = 8
)(
    input   [DATA_WIDTH-1:0]  bin,
    output  [DATA_WIDTH-1:0]  gray
);

assign gray = {1'b0, bin[DATA_WIDTH-1:1]} ^ bin;

//另一种方法：
//assign oGrayCode = (iBinary >> 1) ^ iBinary

endmodule
```

# FPGA状态机的实现方式

FPGA状态机的描述方式主要分为3种，分别是一段式、两段式、三段式。

- 写状态机时最好使用三段式的状态机，第一个状态机只写当前状态以及下一个状态；第二个状态机写下一个状态的跳转条件以及跳转状态；第三个状态机写输出。一般来说,状态转移部分（第一个状态机）是同步时序电路而状态的转移条件的判断（第二个状态机）是组合逻辑。

- 三段式描述方法与两段式描述相比，虽然代码结构复杂了一些，但是换来的优势是使FSM （有限状态机[有限状态机FSM详解（一）_fsm模型-CSDN博客](https://blog.csdn.net/benjonc/article/details/79870947)）做到了同步寄存器输出，消除了组合逻辑输出的不稳定与毛刺的隐患，而且更利于时序路径分组，一般来说在FPGA/CPLD 等可编程逻辑器件上的综合与布局布线效果更佳。
  原文链接：https://blog.csdn.net/Next_FSE/article/details/73864370
- **具体实例可见：[FPGA状态机详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/618712669)**



